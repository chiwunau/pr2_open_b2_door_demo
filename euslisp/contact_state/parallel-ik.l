(defun split-sampling (&key (robot *pr2*) (door *door*) (nodes *all-nodes*) (optimize-exist-pose nil) index)
  ;; (update-loaded-nodes :robot robot :door door :nodes nodes)
  ;; (send viewer :objects robot)
  ;; (send viewer :objects door)
  ;; (send viewer :draw-objects)
  (robot-pose-sampling :robot robot :door door :nodes nodes :optimize-exist-pose optimize-exist-pose)
  (format t "Finish! Robot:~A Door:~A~%" robot door)
  t)


(setq num-threads 6)
(sys::make-thread (* num-threads 2) (* 10 32 1024))
(setq robots nil)
(setq doors nil)
;; (setq viewers nil)

(dotimes (i num-threads)
  (let ((r (pr2)))
    (send r :make-collision-model-for-links)
    (send (car (send r :torso :parent-link)) :make-pqpmodel)
    (push r robots)
    (push (make-602exp-door) doors)
    ;; (push (make-irtviewer) viewers)
    ))

(init)
(init-all-container-nodes) ;;->*all-nodes*



(defun parallel-sampling ()
  (let (rns0 rns1 rns2 lns0 lns1 lns2 ns-list)
    (dolist (n *all-nodes*)
      (cond ((and (equal (send n :get-value :arm) :rarm) (eq (send n :get-value :contact-point-index) 0))
             (push n rns0))
            ((and (equal (send n :get-value :arm) :rarm) (eq (send n :get-value :contact-point-index) 1))
             (push n rns1))
            ((and (equal (send n :get-value :arm) :rarm) (eq (send n :get-value :contact-point-index) 2))
             (push n rns2))
            ((and (equal (send n :get-value :arm) :larm) (eq (send n :get-value :contact-point-index) 0))
             (push n lns0))
            ((and (equal (send n :get-value :arm) :larm) (eq (send n :get-value :contact-point-index) 1))
             (push n lns1))
            ((and (equal (send n :get-value :arm) :larm) (eq (send n :get-value :contact-point-index) 2))
             (push n lns2))
            (t
             nil)))
    (setq ns-list (list (reverse rns0) (reverse rns1) (reverse rns2) (reverse lns0) (reverse lns1) (reverse lns2)))
    (do ((i 0 (+ i 1))) ((>= i (length ns-list)))
        (update-loaded-nodes :robot (elt robots i) :door (elt doors i) :nodes (elt ns-list i))
        ))

  
  (do ((depth 0 (+ depth 1))) ((>= depth *graph-depth*))
  ;; (do ((depth 3 (+ depth 1))) ((>= depth 4))
      (format t "Depth:~A~%" depth)
      (unix:usleep (* 1000 1000))
      (setq tids nil)
      (setq results nil)
      (print (length (sys::free-threads)))
      (let (rns0 rns1 rns2 lns0 lns1 lns2)
        (dolist (n *all-nodes*)
          (when (eq (send n :get-value :graph-depth) depth)
            (cond ((and (equal (send n :get-value :arm) :rarm) (eq (send n :get-value :contact-point-index) 0))
                   (push n rns0))
                  ((and (equal (send n :get-value :arm) :rarm) (eq (send n :get-value :contact-point-index) 1))
                   (push n rns1))
                  ((and (equal (send n :get-value :arm) :rarm) (eq (send n :get-value :contact-point-index) 2))
                   (push n rns2))
                  ((and (equal (send n :get-value :arm) :larm) (eq (send n :get-value :contact-point-index) 0))
                   (push n lns0))
                  ((and (equal (send n :get-value :arm) :larm) (eq (send n :get-value :contact-point-index) 1))
                   (push n lns1))
                  ((and (equal (send n :get-value :arm) :larm) (eq (send n :get-value :contact-point-index) 2))
                   (push n lns2))
                  )))
        (setq ns-list (list (reverse rns0) (reverse rns1) (reverse rns2) (reverse lns0) (reverse lns1) (reverse lns2)))
        ;; (setq ns-list (list (subseq (reverse rns0) 0 4) (subseq (reverse rns1) 0 4) (subseq (reverse rns2) 0 4) (subseq (reverse lns0) 0 4) (subseq (reverse lns1) 0 4) (subseq (reverse lns2) 0 4)))
        ;; (print ns-list)

        (do ((i 0 (+ i 1))) ((>= i (length ns-list)))
            (push (sys::thread #'split-sampling :robot (elt robots i) :door (elt doors i) :nodes (elt ns-list i)  :optimize-exist-pose nil :index i) tids)
            (unix:usleep (* 1000 500))
            ;; (push (sys::thread #'split-sampling :robot (elt robots i) :door (elt doors i) :index i) tids)
            ;; (unix:usleep (* 1000 4000))
            )
        (print "Wait threads free")
        (dolist (tid tids)
          (push (sys:wait-thread tid) results)
          )
        )
      )
  )


;; (robot-pose-sampling :nodes (list (get-node "r-0-3-1")) :robot (elt robots 0) :door (elt doors 0) :optimize-exist-pose t)
